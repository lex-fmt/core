#!/bin/bash
#
# Pre-commit hook for Rust projects
# This script runs formatting, linting, and testing to ensure code quality
#
# Usage:
#   ./scripts/pre-commit           # Run on staged files (git hook mode)
#   ./scripts/pre-commit --all     # Run on all Rust files (manual mode)
#
# To install this hook, run:
#   ln -sf ../../scripts/pre-commit .git/hooks/pre-commit
#   chmod +x .git/hooks/pre-commit

set -e

# Ensure Rust tools are in PATH
if ! command -v cargo >/dev/null 2>&1; then
    # Try .envrc first (direnv integration)
    if [ -f ".envrc" ]; then
        # Source relevant parts of .envrc for PATH setup
        # This mimics what direnv would do
        PROJECT_ROOT="$PWD"
        SCRIPTS_ROOT="$PROJECT_ROOT/scripts"
        
        # 1. Standard cargo location
        if [ -d "$HOME/.cargo/bin" ]; then
            export PATH="$HOME/.cargo/bin:$PATH"
        fi
        
        # 2. Source cargo env if available
        if [ -f "$HOME/.cargo/env" ]; then
            source "$HOME/.cargo/env"
        fi
        
        # 3. Find cargo via rustup if available
        if command -v rustup >/dev/null 2>&1; then
            CARGO_PATH=$(rustup which cargo 2>/dev/null)
            if [ -n "$CARGO_PATH" ]; then
                CARGO_BIN_DIR=$(dirname "$CARGO_PATH")
                export PATH="$CARGO_BIN_DIR:$PATH"
            fi
        fi
    fi
    
    # If still not found, try common Rust installation paths
    if ! command -v cargo >/dev/null 2>&1; then
        if [ -d "$HOME/.rustup/toolchains" ]; then
            # Find the active toolchain
            TOOLCHAIN_PATH=$(find "$HOME/.rustup/toolchains" -name "bin" -type d | head -1)
            if [ -n "$TOOLCHAIN_PATH" ]; then
                export PATH="$TOOLCHAIN_PATH:$PATH"
            fi
        fi
    fi
fi

echo "ğŸ¦€ Running pre-commit checks for Rust project..."

# Check if --all flag is provided
if [ "$1" = "--all" ]; then
    echo "ğŸ“ Running checks on all Rust files in the project..."
    STAGED_FILES=$(find . -name "*.rs" -not -path "./target/*" -not -path "./.git/*")
    ALL_MODE=true
    
    if [ -z "$STAGED_FILES" ]; then
        echo "â„¹ï¸  No Rust files found in the project"
        exit 0
    fi
    
    echo "ğŸ“ Found $(echo "$STAGED_FILES" | wc -l) Rust files"
else
    # Get list of staged Rust files
    STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(rs)$' || true)
    ALL_MODE=false
    
    if [ -z "$STAGED_FILES" ]; then
        echo "â„¹ï¸  No Rust files staged for commit"
        exit 0
    fi
    
    echo "ğŸ“ Staged Rust files:"
    echo "$STAGED_FILES" | sed 's/^/  /'
fi

# 1. Auto-fix code formatting
echo ""
echo "ğŸ¨ Checking and fixing code formatting..."
if ! cargo fmt -- --check >/dev/null 2>&1; then
    echo "ğŸ”§ Auto-fixing formatting issues..."
    cargo fmt
    if [ "$ALL_MODE" = "false" ]; then
        # Re-stage files that were formatted
        echo "$STAGED_FILES" | xargs git add
        echo "âœ… Code formatting fixed and files re-staged"
    else
        echo "âœ… Code formatting fixed"
    fi
else
    echo "âœ… Code formatting is correct"
fi

# 2. Run Clippy lints with auto-fix
echo ""
echo "ğŸ” Running Clippy lints with auto-fix..."
# First try to auto-fix what we can
if cargo clippy --fix --all-targets --all-features --allow-dirty --allow-staged 2>/dev/null; then
    if [ "$ALL_MODE" = "false" ] && [ -n "$STAGED_FILES" ]; then
        # Re-stage files that were fixed
        echo "$STAGED_FILES" | xargs git add 2>/dev/null || true
        echo "ğŸ”§ Auto-fixed some Clippy issues and re-staged files"
    else
        echo "ğŸ”§ Auto-fixed some Clippy issues"
    fi
fi

# Now run clippy to check for remaining issues
if ! cargo clippy --all-targets --all-features -- -D warnings; then
    echo "âŒ Clippy found issues that require manual fixing!"
    echo "ğŸ’¡ Fix the issues above"
    exit 1
fi
echo "âœ… Clippy checks passed"

# 3. Check that code compiles
echo ""
echo "ğŸ”¨ Checking compilation..."
if ! cargo check --all-targets --all-features; then
    echo "âŒ Compilation failed!"
    exit 1
fi
echo "âœ… Code compiles successfully"

# 4. Run tests
echo ""
echo "ğŸ§ª Running tests..."
if ! cargo test --all-features; then
    echo "âŒ Tests failed!"
    exit 1
fi
echo "âœ… All tests passed"

# 5. Check documentation builds
echo ""
echo "ğŸ“š Checking documentation..."
if ! cargo doc --no-deps --all-features; then
    echo "âŒ Documentation build failed!"
    exit 1
fi
echo "âœ… Documentation builds successfully"

# 6. Security audit (optional, only if cargo-audit is installed)
if command -v cargo-audit >/dev/null 2>&1; then
    echo ""
    echo "ğŸ”’ Running security audit..."
    if ! cargo audit; then
        echo "âš ï¸  Security audit found issues!"
        echo "ğŸ’¡ Review the issues above. You may proceed if they're acceptable."
        echo "ğŸ’¡ Install cargo-audit with: cargo install cargo-audit"
        # Don't fail the commit for audit issues, just warn
    else
        echo "âœ… Security audit passed"
    fi
else
    echo ""
    echo "â„¹ï¸  Skipping security audit (cargo-audit not installed)"
    echo "ğŸ’¡ Install with: cargo install cargo-audit"
fi

# 7. Check for TODO/FIXME comments in files (optional warning)
if [ -n "$STAGED_FILES" ]; then
    TODO_COUNT=$(echo "$STAGED_FILES" | xargs grep -n "TODO\|FIXME" 2>/dev/null || true | wc -l)
    if [ "$TODO_COUNT" -gt 0 ]; then
        echo ""
        if [ "$ALL_MODE" = "true" ]; then
            echo "âš ï¸  Found $TODO_COUNT TODO/FIXME comments in project files:"
        else
            echo "âš ï¸  Found $TODO_COUNT TODO/FIXME comments in staged files:"
        fi
        echo "$STAGED_FILES" | xargs grep -n "TODO\|FIXME" 2>/dev/null || true
        echo "ğŸ’¡ Consider addressing these before committing"
    fi
fi

echo ""
echo "ğŸ‰ All pre-commit checks passed! Ready to commit."