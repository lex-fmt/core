#!/bin/bash
#
# Generate AST files for all txxt specification files
#
# This script processes all .txxt files in docs/specs/v1 and generates
# corresponding AST output files based on the specified format.
#
# Usage:
#   ./scripts/generate-specs-asts [--format FORMAT]
#
# Options:
#   --format FORMAT    Output format (default: ast-tag)
#                      Examples: ast-tag, ast-treeviz, ast-position

set -uo pipefail

# Parse command line arguments
FORMAT="ast-tag"
REMOVE_ALL=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --format)
            FORMAT="$2"
            shift 2
            ;;
        --remove-all)
            REMOVE_ALL=true
            shift
            ;;
        --help|-h)
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --format FORMAT    Output format (default: ast-tag)"
            echo "                     Examples: ast-tag, ast-treeviz, ast-position"
            echo "  --remove-all       Remove all *.ast.* files (both xml and treeviz)"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Convert format to file extension
# Pattern: <original>.ast.<format>
# ast-tag -> format is "xml" -> .ast.xml
# ast-treeviz -> format is "treeviz" -> .ast.treeviz
# ast-position -> format is "position" -> .ast.position
if [[ "$FORMAT" =~ ^ast- ]]; then
    # Extract the part after "ast-"
    FORMAT_SUFFIX="${FORMAT#ast-}"
    # Special case: tag -> xml
    if [ "$FORMAT_SUFFIX" = "tag" ]; then
        FORMAT_SUFFIX="xml"
    fi
    EXTENSION=".ast.${FORMAT_SUFFIX}"
else
    # Fallback: use the format as-is
    EXTENSION=".ast.${FORMAT}"
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
SPECS_DIR="$PROJECT_ROOT/docs/specs/v1"

# Temporary files for tracking
ERROR_FILE="/tmp/txxt_ast_errors_$$.txt"
COUNT_FILE="/tmp/txxt_ast_counts_$$.txt"

# Initialize counters
echo "0" > "$COUNT_FILE"
echo "0" > "$ERROR_FILE.count"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Cleanup function
cleanup() {
    rm -f "$ERROR_FILE" "$ERROR_FILE.count" "$COUNT_FILE" 2>/dev/null || true
}
trap cleanup EXIT

echo "ğŸ” Finding all .txxt files in docs/specs/v1..."
echo "ğŸ“‹ Format: $FORMAT"
echo ""

# Count files first
TXXT_COUNT=$(find "$SPECS_DIR" -type f -name "*.txxt" 2>/dev/null | wc -l | tr -d ' ')

if [ "$TXXT_COUNT" -eq "0" ]; then
    echo "âŒ No .txxt files found in $SPECS_DIR"
    exit 1
fi

echo "ğŸ“ Found $TXXT_COUNT .txxt file(s) to process"
echo ""

# Clean up existing files
if [ "$REMOVE_ALL" = true ]; then
    echo "ğŸ§¹ Removing all *.ast.* files..."
    ALL_AST_COUNT=$(find "$SPECS_DIR" -type f -name "*.ast.*" 2>/dev/null | wc -l | tr -d ' ')
    
    if [ "$ALL_AST_COUNT" -gt "0" ]; then
        find "$SPECS_DIR" -type f -name "*.ast.*" -delete
        echo "   Removed $ALL_AST_COUNT existing *.ast.* file(s)"
    else
        echo "   No existing *.ast.* files to remove"
    fi
else
    # Clean up existing files with the target extension only
    echo "ğŸ§¹ Cleaning up existing *${EXTENSION} files..."
    AST_XML_COUNT=$(find "$SPECS_DIR" -type f -name "*${EXTENSION}" 2>/dev/null | wc -l | tr -d ' ')
    
    if [ "$AST_XML_COUNT" -gt "0" ]; then
        find "$SPECS_DIR" -type f -name "*${EXTENSION}" -delete
        echo "   Removed $AST_XML_COUNT existing *${EXTENSION} file(s)"
    else
        echo "   No existing *${EXTENSION} files to remove"
    fi
fi
echo ""

# Change to project root to run cargo commands
cd "$PROJECT_ROOT"

# Process each file
find "$SPECS_DIR" -type f -name "*.txxt" | sort | while read -r TXXT_FILE; do
    # Get relative path from project root
    REL_PATH="${TXXT_FILE#$PROJECT_ROOT/}"
    
    # Calculate output path: same path but with the format-specific extension
    OUTPUT_FILE="${TXXT_FILE}${EXTENSION}"
    
    echo -n "Processing: $REL_PATH ... "
    
    # Run the cargo command and capture output and exit code
    OUTPUT=$(cargo run --bin txxt -- "$TXXT_FILE" "$FORMAT" 2>&1) && EXIT_CODE=0 || EXIT_CODE=$?
    
    if [ $EXIT_CODE -eq 0 ]; then
        # Command succeeded, save output to file
        echo "$OUTPUT" > "$OUTPUT_FILE"
        echo -e "${GREEN}âœ“${NC}"
        # Increment success count
        SUCCESS=$(cat "$COUNT_FILE")
        echo $((SUCCESS + 1)) > "$COUNT_FILE"
    else
        # Command failed
        echo -e "${RED}âœ—${NC} (exit code: $EXIT_CODE)"
        # Track error file
        echo "$REL_PATH" >> "$ERROR_FILE"
        ERROR_COUNT=$(cat "$ERROR_FILE.count")
        echo $((ERROR_COUNT + 1)) > "$ERROR_FILE.count"
    fi
done

# Read final counts
SUCCESS_COUNT=$(cat "$COUNT_FILE" 2>/dev/null || echo "0")
ERROR_COUNT=$(cat "$ERROR_FILE.count" 2>/dev/null || echo "0")

# Print summary
echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "Summary"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo -e "Files generated: ${GREEN}$SUCCESS_COUNT${NC}"
echo -e "Errors: ${RED}$ERROR_COUNT${NC}"

if [ "$ERROR_COUNT" -gt 0 ] && [ -f "$ERROR_FILE" ]; then
    echo ""
    echo "Files with errors:"
    while IFS= read -r ERR_FILE; do
        echo -e "  ${RED}âœ—${NC} $ERR_FILE"
    done < "$ERROR_FILE"
    exit 1
else
    echo ""
    echo -e "${GREEN}âœ“ All files processed successfully!${NC}"
    exit 0
fi
