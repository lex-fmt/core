#!/bin/bash
#
# Generate AST files for all txxt specification files
#
# This script processes all .txxt files in docs/specs/v1 and generates
# corresponding AST output files based on the specified format.
#
# Usage:
#   ./scripts/generate-specs-asts [--format FORMAT]
#
# Options:
#   --format FORMAT    Output format (default: ast-tag)
#                      Examples: ast-tag, ast-treeviz, ast-position

set -uo pipefail

# Parse command line arguments
FORMAT="ast-tag"

while [[ $# -gt 0 ]]; do
    case $1 in
        --format)
            FORMAT="$2"
            shift 2
            ;;
        --help|-h)
            echo "Usage: $0 [--format FORMAT]"
            echo ""
            echo "Options:"
            echo "  --format FORMAT    Output format (default: ast-tag)"
            echo "                     Examples: ast-tag, ast-treeviz, ast-position"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Convert format to file extension
# ast-tag -> .ast.xml
# ast-treeviz -> .treeviz
# Other formats -> .txt (e.g., ast-position -> ast-position.txt)
if [ "$FORMAT" = "ast-tag" ]; then
    EXTENSION=".ast.xml"
elif [ "$FORMAT" = "ast-treeviz" ]; then
    EXTENSION=".ast.treeviz"
else
    # For all other formats, use .txt extension
    EXTENSION=".${FORMAT}.txt"
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
SPECS_DIR="$PROJECT_ROOT/docs/specs/v1"

# Temporary files for tracking
ERROR_FILE="/tmp/txxt_ast_errors_$$.txt"
COUNT_FILE="/tmp/txxt_ast_counts_$$.txt"

# Initialize counters
echo "0" > "$COUNT_FILE"
echo "0" > "$ERROR_FILE.count"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Cleanup function
cleanup() {
    rm -f "$ERROR_FILE" "$ERROR_FILE.count" "$COUNT_FILE" 2>/dev/null || true
}
trap cleanup EXIT

echo "๐ Finding all .txxt files in docs/specs/v1..."
echo "๐ Format: $FORMAT"
echo ""

# Count files first
TXXT_COUNT=$(find "$SPECS_DIR" -type f -name "*.txxt" 2>/dev/null | wc -l | tr -d ' ')

if [ "$TXXT_COUNT" -eq "0" ]; then
    echo "โ No .txxt files found in $SPECS_DIR"
    exit 1
fi

echo "๐ Found $TXXT_COUNT .txxt file(s) to process"
echo ""

# Clean up existing files with the target extension
echo "๐งน Cleaning up existing *${EXTENSION} files..."
AST_XML_COUNT=$(find "$SPECS_DIR" -type f -name "*${EXTENSION}" 2>/dev/null | wc -l | tr -d ' ')

if [ "$AST_XML_COUNT" -gt "0" ]; then
    find "$SPECS_DIR" -type f -name "*${EXTENSION}" -delete
    echo "   Removed $AST_XML_COUNT existing *${EXTENSION} file(s)"
else
    echo "   No existing *${EXTENSION} files to remove"
fi
echo ""

# Change to project root to run cargo commands
cd "$PROJECT_ROOT"

# Process each file
find "$SPECS_DIR" -type f -name "*.txxt" | sort | while read -r TXXT_FILE; do
    # Get relative path from project root
    REL_PATH="${TXXT_FILE#$PROJECT_ROOT/}"
    
    # Calculate output path: same path but with the format-specific extension
    OUTPUT_FILE="${TXXT_FILE}${EXTENSION}"
    
    echo -n "Processing: $REL_PATH ... "
    
    # Run the cargo command and capture output and exit code
    OUTPUT=$(cargo run --bin txxt -- "$TXXT_FILE" "$FORMAT" 2>&1) && EXIT_CODE=0 || EXIT_CODE=$?
    
    if [ $EXIT_CODE -eq 0 ]; then
        # Command succeeded, save output to file
        echo "$OUTPUT" > "$OUTPUT_FILE"
        echo -e "${GREEN}โ${NC}"
        # Increment success count
        SUCCESS=$(cat "$COUNT_FILE")
        echo $((SUCCESS + 1)) > "$COUNT_FILE"
    else
        # Command failed
        echo -e "${RED}โ${NC} (exit code: $EXIT_CODE)"
        # Track error file
        echo "$REL_PATH" >> "$ERROR_FILE"
        ERROR_COUNT=$(cat "$ERROR_FILE.count")
        echo $((ERROR_COUNT + 1)) > "$ERROR_FILE.count"
    fi
done

# Read final counts
SUCCESS_COUNT=$(cat "$COUNT_FILE" 2>/dev/null || echo "0")
ERROR_COUNT=$(cat "$ERROR_FILE.count" 2>/dev/null || echo "0")

# Print summary
echo ""
echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
echo "Summary"
echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
echo -e "Files generated: ${GREEN}$SUCCESS_COUNT${NC}"
echo -e "Errors: ${RED}$ERROR_COUNT${NC}"

if [ "$ERROR_COUNT" -gt 0 ] && [ -f "$ERROR_FILE" ]; then
    echo ""
    echo "Files with errors:"
    while IFS= read -r ERR_FILE; do
        echo -e "  ${RED}โ${NC} $ERR_FILE"
    done < "$ERROR_FILE"
    exit 1
else
    echo ""
    echo -e "${GREEN}โ All files processed successfully!${NC}"
    exit 0
fi
