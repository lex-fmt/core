There is a design issue, compounded by a bunch of halfway refactors that have left part of the design and everything up to the final implementation very confusing in lex.
This has spawned a number of problems and issues (#85 #86 and many more)

This document aims to give context and the rationale so that we can plan how best to address it.

1. The Principle

    To avoid confusion with the current names, I'll use names that are neither implemented nor suggested.
    The core characteristic of lex is that all elements are nestable. The only exception being paragraphs for obvious reasons.

    Every element has a standard form. It has a "lead" (as in news lead), the thing that draws attention to it. Mostly a short bit of text.
    And it may have content, which are, by lex's recursive nature, its children.

    The base form is:

    <lead>
    <container> -> all children go here
    <child> ...
    </container>

    The first key thing to note is that indentation always denotes nesting / parent-child relationship.
    What gets indented is the container element where children are attached.

    Each element has a variation for this, driven by semantics, user's expectations and avoiding parsing ambiguities.

2. Elements

    1. Sessions

        Structure:
        <blank-line>
        <session>
            <session title> -> the lead
            <blank-line>
            <container>
                <child> Can be any element
            </container>
        </session>

        For example:

        Welcome to parsing

            The world of parsers is a wonderful one.

        This explains why the title is not indented, while the children nodes are indented.
        The indentation is caused by the session's container that carries children.

    2. List Items

        Structure:
        <list-item>
            <text> -> the lead
            <container>
                <list>
                    <list-item> foo
                </list>
            </container>
        </list-item>

        For example:

        - Groceries:
            - Bread

        Bread is the text for the first list item of the list that is the first child of the Groceries list item.
        This is why lists are not indented. If they were, the top level would be too.
        The indentation is caused by the item's container that carries children (in this case another item).

    3. Definitions

        Structure:
        <definition>
            <term>Term</term> -> the lead
            <container>
                <paragraph>... <- children go here
            </container>
        </definition>

        For example:

        Parsing:
            The art of extracting structure from the lack of.

        Parsing is the lead, then its content, inside the container are its children.

    4. Verbatim

        Structure:
        <foreign>
            <subject>Verbatim</subject> -> the lead
            <container>
                whatever (optional)
            </container>
        </foreign>
        <annotation>

        For example:

            any content here (indented)

        :: foo ::

        Any content here is the lead, then the annotation follows. The indentation denotes the container for the foreign element's children.

    5. Annotations

        Annotations are the odd ones here.

        First they have a dual form, which we can ignore.
        Just consider that:

        :: label :: Content

        is just a shortcut for:

        :: label::
            Content

        Aside from the shorthand form that hides the common design, the label is different in that it can be omitted, and is a machine readable identifier, not really content. Which makes more sense when you remember that annotations are metadata, not content.
        The label can be omitted because, unlike all others, this element has explicit syntax (lex marker) that can clearly demarcate the element.

        Structure:
        <annotation>
            <label>Label</label> -> the lead (optional)
            <container>
                <content>... <- children go here
            </container>
        </annotation>

        For example:

        :: label::
            Content

    The label is the lead (optional), then its content, inside the container are its children.

    6. Summary

        Element          Lead                  Children Req.        Ends with       Blank Line      Starts With
        ---------------------------------------------------------------------------------------------------
        List Item        The item's name       no                   Dedent          Forbidden       Seq Marker
        Session          Title                 yes                  Dedent          Required        Blank Lines
        Definition       Term                  yes                  Dedent          Forbidden       Text + colon (subject)
        Verbatim          Subject               no                  Notation        Optional        Text + colon (subject)
        Annotation       Label (optional)      no                   Dedent          Optional        lex-marker



3. The confusion

    The code was not implemented higlighting the structure but having idiosincrasies.
    The small variations as in requirement of children, the syntax, and blank line behaviour make this fuzzier, but the structure is evident.


    There some clear painpoints here: 

        1. Lack of formatlization breeds confusion

            The absense of this clear structure in the code leads to confusion as in the very need for this documentn.

            This , in turns leads to duplication and almost identical code with sublte differences everywhere.

        2. Difficulty in common Handling

            There is not only a common structure, but common behaviors (of whhich parsing is the most critical)
            The heterogenous interfaces make everything more complicated. 

            I've tried to address it with the container trait that defines common interfaces for the children and lead (called label in it)

            The parsing, in particular is the most severe. 
            I think it would be possible and much esier to have structured one parsing function that would verify a valid label declaration , children container, children content ., etc, with less code, easier to follow and less bugs.



4. The specifics

	1. The name situation
    	
        I could not find a good name for lead. For example: 

        - Heading -> was very tied up to session, but felt wird in a list item.
        - Title: worked for sessions, not else
        - Subject: worked for some, weirth for list item

        And of course, notations's case, the label being an idetifier makes it bad to call it a normal user content thing.
        I don't like label either, but opt for it over id (since it's not unique), tags (only one per element) other options seemed loaded with misleaading understandings.

    2. The Container Especialization Crisis 

        The original plan, called for at least to containers: 
        -  Session Containers: the doc root, the children of any session, including other session.
        - Content Container: All content but session , the one in all other elmeelents (you dont'want to start a session inside a list item)

        However, due to techinical constraints involving recursion and parser combinators we had to choose between doing a proper recursive structure (what we chose) with only one container type and having spread out non recursinve functions to each content type.

        This is a side note: we will either retry that or handle as validation post parsing.


5. The Ask

    Given the history and rationale, I'm not sure the right way to proceed here: 
    - refactor the code to have a common sturcture (what names)? 
    - Add some comments? 
    - Ignore? 
    - Other improvements I do not see

    